// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.2 effective-5.10 (swiftlang-6.0.2.1.2 clang-1600.0.26.4)
// swift-module-flags: -target arm64-apple-ios16.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -enable-bare-slash-regex -module-name patrol
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import CocoaAsyncSocket
import CommonCrypto
import Flutter
import Foundation
import MobileCoreServices
import Security
import Swift
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@_exported import patrol
extension Swift.Array {
  public func first<T>(ofType: T.Type) -> T?
  public func filter<T>(ofType: T.Type) -> [T]
}
extension patrol.Selector {
  public func toTextFieldNSPredicate() -> Foundation.NSPredicate
  public func toNSPredicate() -> Foundation.NSPredicate
}
open class Certificate : Swift.RawRepresentable {
  final public let rawValue: Security.SecCertificate
  required public init(rawValue: Security.SecCertificate)
  convenience public init?(derData: Foundation.Data)
  convenience public init?(derURL: Foundation.URL)
  public typealias RawValue = Security.SecCertificate
  @objc deinit
}
extension patrol.Certificate {
  public var commonName: Swift.String? {
    get
  }
}
extension patrol.Certificate {
  convenience public init(fromKeychain label: Swift.String) throws
  public func addToKeychain(label: Swift.String) throws
  public static func removeFromKeychain(label: Swift.String) throws
}
open class CertificateIdentity : Swift.RawRepresentable {
  final public let rawValue: Security.SecIdentity
  required public init(rawValue: Security.SecIdentity)
  convenience public init?(p12Data: Foundation.Data, passphrase: Swift.String)
  convenience public init?(p12URL: Foundation.URL, passphrase: Swift.String)
  public typealias RawValue = Security.SecIdentity
  @objc deinit
}
extension patrol.CertificateIdentity {
  convenience public init(fromKeychain label: Swift.String) throws
  public func addToKeychain(label: Swift.String) throws
  public static func removeFromKeychain(label: Swift.String) throws
}
extension patrol.CertificateIdentity {
  convenience public init?(p12Data: Foundation.Data)
  convenience public init?(p12URL: Foundation.URL)
}
extension patrol.HTTPConfig {
  public static var clientDefault: patrol.HTTPConfig {
    get
  }
}
extension patrol.WebSocketConfig {
  public static var clientDefault: patrol.WebSocketConfig {
    get
  }
}
public enum GroupEntryType : Swift.String, Swift.Codable {
  case group
  case test
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum RunDartTestResponseResult : Swift.String, Swift.Codable {
  case success
  case skipped
  case failure
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KeyboardBehavior : Swift.String, Swift.Codable {
  case showAndDismiss
  case alternative
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum HandlePermissionRequestCode : Swift.String, Swift.Codable {
  case whileUsing
  case onlyThisTime
  case denied
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum SetLocationAccuracyRequestLocationAccuracy : Swift.String, Swift.Codable {
  case coarse
  case fine
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum IOSElementType : Swift.String, Swift.Codable {
  case any
  case other
  case application
  case group
  case window
  case sheet
  case drawer
  case alert
  case dialog
  case button
  case radioButton
  case radioGroup
  case checkBox
  case disclosureTriangle
  case popUpButton
  case comboBox
  case menuButton
  case toolbarButton
  case popover
  case keyboard
  case key
  case navigationBar
  case tabBar
  case tabGroup
  case toolbar
  case statusBar
  case table
  case tableRow
  case tableColumn
  case outline
  case outlineRow
  case browser
  case collectionView
  case slider
  case pageIndicator
  case progressIndicator
  case activityIndicator
  case segmentedControl
  case picker
  case pickerWheel
  case switch_
  case toggle
  case link
  case image
  case icon
  case searchField
  case scrollView
  case scrollBar
  case staticText
  case textField
  case secureTextField
  case datePicker
  case textView
  case menu
  case menuItem
  case menuBar
  case menuBarItem
  case map
  case webView
  case incrementArrow
  case decrementArrow
  case timeline
  case ratingIndicator
  case valueIndicator
  case splitGroup
  case splitter
  case relevanceIndicator
  case colorWell
  case helpTag
  case matte
  case dockItem
  case ruler
  case rulerMarker
  case grid
  case levelIndicator
  case cell
  case layoutArea
  case layoutItem
  case handle
  case stepper
  case tab
  case touchBar
  case statusItem
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct DartGroupEntry : Swift.Codable {
  public var name: Swift.String
  public var type: patrol.GroupEntryType
  public var entries: [patrol.DartGroupEntry]
  public var skip: Swift.Bool
  public var tags: [Swift.String]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ListDartTestsResponse : Swift.Codable {
  public var group: patrol.DartGroupEntry
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RunDartTestRequest : Swift.Codable {
  public var name: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RunDartTestResponse : Swift.Codable {
  public var result: patrol.RunDartTestResponseResult
  public var details: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ConfigureRequest : Swift.Codable {
  public var findTimeoutMillis: Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct OpenAppRequest : Swift.Codable {
  public var appId: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct OpenQuickSettingsRequest : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct OpenUrlRequest : Swift.Codable {
  public var url: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct AndroidSelector : Swift.Codable {
  public var className: Swift.String?
  public var isCheckable: Swift.Bool?
  public var isChecked: Swift.Bool?
  public var isClickable: Swift.Bool?
  public var isEnabled: Swift.Bool?
  public var isFocusable: Swift.Bool?
  public var isFocused: Swift.Bool?
  public var isLongClickable: Swift.Bool?
  public var isScrollable: Swift.Bool?
  public var isSelected: Swift.Bool?
  public var applicationPackage: Swift.String?
  public var contentDescription: Swift.String?
  public var contentDescriptionStartsWith: Swift.String?
  public var contentDescriptionContains: Swift.String?
  public var text: Swift.String?
  public var textStartsWith: Swift.String?
  public var textContains: Swift.String?
  public var resourceName: Swift.String?
  public var instance: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct IOSSelector : Swift.Codable {
  public var value: Swift.String?
  public var instance: Swift.Int?
  public var elementType: patrol.IOSElementType?
  public var identifier: Swift.String?
  public var label: Swift.String?
  public var labelStartsWith: Swift.String?
  public var labelContains: Swift.String?
  public var title: Swift.String?
  public var titleStartsWith: Swift.String?
  public var titleContains: Swift.String?
  public var hasFocus: Swift.Bool?
  public var isEnabled: Swift.Bool?
  public var isSelected: Swift.Bool?
  public var placeholderValue: Swift.String?
  public var placeholderValueStartsWith: Swift.String?
  public var placeholderValueContains: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Selector : Swift.Codable {
  public var text: Swift.String?
  public var textStartsWith: Swift.String?
  public var textContains: Swift.String?
  public var className: Swift.String?
  public var contentDescription: Swift.String?
  public var contentDescriptionStartsWith: Swift.String?
  public var contentDescriptionContains: Swift.String?
  public var resourceId: Swift.String?
  public var instance: Swift.Int?
  public var enabled: Swift.Bool?
  public var focused: Swift.Bool?
  public var pkg: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct GetNativeViewsRequest : Swift.Codable {
  public var selector: patrol.Selector?
  public var androidSelector: patrol.AndroidSelector?
  public var iosSelector: patrol.IOSSelector?
  public var appId: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct GetNativeUITreeRequest : Swift.Codable {
  public var iosInstalledApps: [Swift.String]?
  public var useNativeViewHierarchy: Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct GetNativeUITreeRespone : Swift.Codable {
  public var iOSroots: [patrol.IOSNativeView]
  public var androidRoots: [patrol.AndroidNativeView]
  public var roots: [patrol.NativeView]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct AndroidNativeView : Swift.Codable {
  public var resourceName: Swift.String?
  public var text: Swift.String?
  public var className: Swift.String?
  public var contentDescription: Swift.String?
  public var applicationPackage: Swift.String?
  public var childCount: Swift.Int
  public var isCheckable: Swift.Bool
  public var isChecked: Swift.Bool
  public var isClickable: Swift.Bool
  public var isEnabled: Swift.Bool
  public var isFocusable: Swift.Bool
  public var isFocused: Swift.Bool
  public var isLongClickable: Swift.Bool
  public var isScrollable: Swift.Bool
  public var isSelected: Swift.Bool
  public var visibleBounds: patrol.Rectangle
  public var visibleCenter: patrol.Point2D
  public var children: [patrol.AndroidNativeView]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct IOSNativeView : Swift.Codable {
  public var children: [patrol.IOSNativeView]
  public var elementType: patrol.IOSElementType
  public var identifier: Swift.String
  public var label: Swift.String
  public var title: Swift.String
  public var hasFocus: Swift.Bool
  public var isEnabled: Swift.Bool
  public var isSelected: Swift.Bool
  public var frame: patrol.Rectangle
  public var placeholderValue: Swift.String?
  public var value: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Rectangle : Swift.Codable {
  public var minX: Swift.Double
  public var minY: Swift.Double
  public var maxX: Swift.Double
  public var maxY: Swift.Double
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Point2D : Swift.Codable {
  public var x: Swift.Double
  public var y: Swift.Double
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NativeView : Swift.Codable {
  public var className: Swift.String?
  public var text: Swift.String?
  public var contentDescription: Swift.String?
  public var focused: Swift.Bool
  public var enabled: Swift.Bool
  public var childCount: Swift.Int?
  public var resourceName: Swift.String?
  public var applicationPackage: Swift.String?
  public var children: [patrol.NativeView]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct GetNativeViewsResponse : Swift.Codable {
  public var nativeViews: [patrol.NativeView]
  public var iosNativeViews: [patrol.IOSNativeView]
  public var androidNativeViews: [patrol.AndroidNativeView]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TapRequest : Swift.Codable {
  public var selector: patrol.Selector?
  public var androidSelector: patrol.AndroidSelector?
  public var iosSelector: patrol.IOSSelector?
  public var appId: Swift.String
  public var timeoutMillis: Swift.Int?
  public var delayBetweenTapsMillis: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TapAtRequest : Swift.Codable {
  public var x: Swift.Double
  public var y: Swift.Double
  public var appId: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct EnterTextRequest : Swift.Codable {
  public var data: Swift.String
  public var appId: Swift.String
  public var index: Swift.Int?
  public var selector: patrol.Selector?
  public var androidSelector: patrol.AndroidSelector?
  public var iosSelector: patrol.IOSSelector?
  public var keyboardBehavior: patrol.KeyboardBehavior
  public var timeoutMillis: Swift.Int?
  public var dx: Swift.Double
  public var dy: Swift.Double
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct SwipeRequest : Swift.Codable {
  public var appId: Swift.String
  public var startX: Swift.Double
  public var startY: Swift.Double
  public var endX: Swift.Double
  public var endY: Swift.Double
  public var steps: Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct WaitUntilVisibleRequest : Swift.Codable {
  public var selector: patrol.Selector?
  public var androidSelector: patrol.AndroidSelector?
  public var iosSelector: patrol.IOSSelector?
  public var appId: Swift.String
  public var timeoutMillis: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DarkModeRequest : Swift.Codable {
  public var appId: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Notification : Swift.Codable {
  public var appName: Swift.String?
  public var title: Swift.String
  public var content: Swift.String
  public var raw: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct GetNotificationsResponse : Swift.Codable {
  public var notifications: [patrol.Notification]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct GetNotificationsRequest : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TapOnNotificationRequest : Swift.Codable {
  public var index: Swift.Int?
  public var selector: patrol.Selector?
  public var androidSelector: patrol.AndroidSelector?
  public var iosSelector: patrol.IOSSelector?
  public var timeoutMillis: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PermissionDialogVisibleResponse : Swift.Codable {
  public var visible: Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PermissionDialogVisibleRequest : Swift.Codable {
  public var timeoutMillis: Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct HandlePermissionRequest : Swift.Codable {
  public var code: patrol.HandlePermissionRequestCode
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct SetLocationAccuracyRequest : Swift.Codable {
  public var locationAccuracy: patrol.SetLocationAccuracyRequestLocationAccuracy
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension Foundation.Data {
  public static let crlf: Foundation.Data
  public init(randomNumberOfBytes count: Swift.Int)
  public func hexEncodedString() -> Swift.String
  public mutating func mask(with maskBytes: [Swift.UInt8])
}
final public class DataStream {
  final public var position: Swift.Int {
    get
  }
  public init(data: Foundation.Data = Data())
  final public var hasBytesAvailable: Swift.Bool {
    get
  }
  final public func read() -> Swift.UInt8?
  final public func read(count: Swift.Int) -> Foundation.Data
  final public func readToEnd() -> Foundation.Data
  @objc deinit
}
extension Foundation.DateFormatter {
  @available(*, deprecated, renamed: "rfc1123")
  public var rfc7231: Foundation.DateFormatter {
    get
  }
}
extension patrol.DispatchTimer {
  @available(*, deprecated, message: "no longer supported, use start(at:) to run the timer at a later time")
  public static func run(after: Foundation.TimeInterval, interval: Foundation.TimeInterval = 0, queue: Dispatch.DispatchQueue, execute block: @escaping () -> Swift.Void) -> patrol.DispatchTimer
  @available(*, deprecated, message: "no longer supported, use start(at:) to run the timer at a later time")
  final public func start(after: Foundation.TimeInterval)
}
extension Foundation.FileManager {
  @available(*, deprecated, message: "use <url>.mimeType")
  public func mimeType(of url: Foundation.URL) -> Swift.String
}
extension patrol.HTTPHeaderName {
  @available(*, deprecated, message: "construct lower cased names manually")
  public static var forceLowerCased: Swift.Bool
}
extension patrol.HTTPMethod {
  @available(*, deprecated, renamed: "GET")
  public static var get: patrol.HTTPMethod
  @available(*, deprecated, renamed: "HEAD")
  public static var head: patrol.HTTPMethod
  @available(*, deprecated, renamed: "DELETE")
  public static var delete: patrol.HTTPMethod
  @available(*, deprecated, renamed: "OPTIONS")
  public static var options: patrol.HTTPMethod
  @available(*, deprecated, renamed: "POST")
  public static var post: patrol.HTTPMethod
  @available(*, deprecated, renamed: "PUT")
  public static var put: patrol.HTTPMethod
  @available(*, deprecated, renamed: "init(name:)")
  public init(rawValue: Swift.String)
  @available(*, deprecated, renamed: "init(name:)")
  public static func method(_ name: Swift.String) -> patrol.HTTPMethod
}
@available(*, deprecated, message: "these specific errors are no longer thrown")
public enum HTTPRouteError : Swift.Error {
  case invalidURI
  public static func == (a: patrol.HTTPRouteError, b: patrol.HTTPRouteError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension patrol.HTTPStatus {
  @available(*, deprecated, message: "return nil from your handler (this status is used by Nginx, not part of the spec)")
  public static let noResponse: patrol.HTTPStatus
}
@available(*, deprecated, message: "use HTTPStatus, for example .ok or .notFound")
public typealias HTTPStatusCode = patrol.HTTPStatus
extension patrol.HTTPResponse {
  @available(*, deprecated, message: "use DateFormatter.rfc1123 or Date's rfc1123 variable")
  public static let dateFormatter: Foundation.DateFormatter
  @available(*, deprecated, renamed: "init(status:data:)")
  convenience public init(_ status: patrol.HTTPStatus = .ok, data: Foundation.Data)
  @available(*, deprecated, message: "use keepAlive instead, this setter only handles true properly")
  public var closeAfterWrite: Swift.Bool {
    get
    set
  }
}
extension patrol.HTTPVersion {
  @available(*, deprecated, renamed: "init(major:minor:)")
  public init(_ major: Swift.UInt, _ minor: Swift.UInt)
}
extension patrol.Server {
  @available(*, deprecated, renamed: "start(port:)")
  public func start(onPort port: Swift.UInt16) throws
  @available(*, deprecated, renamed: "start(port:interface:)")
  public func start(onInterface interface: Swift.String?, port: Swift.UInt16 = 0) throws
  @available(swift, obsoleted: 5, renamed: "responseFor(request:)")
  public func handleIncoming(request: patrol.HTTPRequest) throws -> patrol.HTTPResponse?
  @available(swift, obsoleted: 5, renamed: "responseFor(error:)")
  public func handleIncoming(error: any Swift.Error) throws -> patrol.HTTPResponse?
}
@_hasMissingDesignatedInitializers final public class DispatchTimer {
  @objc deinit
}
extension patrol.DispatchTimer {
  public static func run(interval: Foundation.TimeInterval, queue: Dispatch.DispatchQueue, execute block: @escaping () -> Swift.Void) -> patrol.DispatchTimer
  public static func run(at: Foundation.Date, interval: Foundation.TimeInterval = 0, queue: Dispatch.DispatchQueue, execute block: @escaping () -> Swift.Void) -> patrol.DispatchTimer
}
public struct Endpoint : Swift.Hashable {
  public typealias Host = Swift.String
  public typealias Port = Swift.Int
  public var host: patrol.Endpoint.Host
  public var port: patrol.Endpoint.Port
  public init(host: patrol.Endpoint.Host, port: patrol.Endpoint.Port)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: patrol.Endpoint, b: patrol.Endpoint) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension patrol.Endpoint {
  public init?(url: Foundation.URL)
  public init(host: patrol.Endpoint.Host, port: Swift.UInt16)
}
extension Foundation.FileManager {
  public func mimeType(pathExtension: Swift.String) -> Swift.String
}
public struct HTTPConfig {
  public var readTimeout: Swift.Double
  public var writeHeaderTimeout: Swift.Double
  public var writeBodyTimeout: Swift.Double
  public var errorHandler: any patrol.HTTPErrorHandler
  public var requestHandlers: [any patrol.HTTPRequestHandler] {
    get
    set
  }
  public init(requestHandlers: [any patrol.HTTPRequestHandler])
}
public protocol HTTPConnectionDelegate : AnyObject {
  func connection(_ httpConnection: patrol.HTTPConnection, didCloseWithError error: (any Swift.Error)?)
  func connection(_ httpConnection: patrol.HTTPConnection, handleIncomingRequest request: patrol.HTTPRequest, error: (any Swift.Error)?)
  func connection(_ httpConnection: patrol.HTTPConnection, handleIncomingResponse response: patrol.HTTPResponse, error: (any Swift.Error)?)
  func connection(_ httpConnection: patrol.HTTPConnection, handleUpgradeByRequest request: patrol.HTTPRequest)
}
public class HTTPConnection : patrol.TCPConnection {
  weak public var delegate: (any patrol.HTTPConnectionDelegate)?
  required public init(socket: patrol.TCPSocket, config: patrol.HTTPConfig)
  public func open()
  public func close(immediately: Swift.Bool)
  public func upgrade() -> (patrol.TCPSocket, Foundation.Data?)
  public func send(data: Foundation.Data, timeout: Foundation.TimeInterval)
  public func send(request: patrol.HTTPRequest)
  public func send(response: patrol.HTTPResponse, toRequest request: patrol.HTTPRequest)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension patrol.HTTPConnection {
  public var localEndpoint: patrol.Endpoint? {
    get
  }
  public var remoteEndpoint: patrol.Endpoint? {
    get
  }
}
extension patrol.HTTPConnection : patrol.TCPSocketDelegate {
  public func socketDidOpen(_ socket: patrol.TCPSocket)
  public func socketDidClose(_ socket: patrol.TCPSocket, error: (any Swift.Error)?)
  public func socketDidRead(_ socket: patrol.TCPSocket, data: Foundation.Data, tag: Swift.Int)
  public func socketDidWrite(_ socket: patrol.TCPSocket, tag: Swift.Int)
}
public enum HTTPError : Swift.Error {
  case unexpectedStreamEnd
  case connectionShouldBeClosed
  case protocolNotSupported
  case invalidContentLength
  case invalidHeader
  case invalidRequest
  case invalidMethod
  case invalidURI
  case invalidVersion
  case headerOverflow
  case parseFailed(code: Swift.Int)
}
extension patrol.HTTPError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension patrol.HTTPError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class HTTPErrorDefaultHandler : patrol.HTTPErrorHandler {
  public func respond(to error: any Swift.Error) -> patrol.HTTPResponse?
  @objc deinit
}
public protocol HTTPErrorHandler {
  func respond(to error: any Swift.Error) -> patrol.HTTPResponse?
}
public typealias HTTPHeaders = [patrol.HTTPHeaderName : Swift.String]
public struct HTTPHeaderName : Swift.Hashable {
  public static func == (lhs: patrol.HTTPHeaderName, rhs: patrol.HTTPHeaderName) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension patrol.HTTPHeaderName : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension patrol.HTTPHeaderName : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral string: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Swift.Dictionary where Key == patrol.HTTPHeaderName, Value == Swift.String {
  public static var empty: patrol.HTTPHeaders {
    get
  }
  public subscript(key: Swift.String) -> Swift.String? {
    get
    set
  }
}
extension patrol.HTTPHeaderName {
  public static let accept: patrol.HTTPHeaderName
  public static let acceptCharset: patrol.HTTPHeaderName
  public static let acceptEncoding: patrol.HTTPHeaderName
  public static let acceptLanguage: patrol.HTTPHeaderName
  public static let acceptRanges: patrol.HTTPHeaderName
  public static let accessControlAllowOrigin: patrol.HTTPHeaderName
  public static let accessControlAllowHeaders: patrol.HTTPHeaderName
  public static let accessControlAllowMethods: patrol.HTTPHeaderName
  public static let accessControlMaxAge: patrol.HTTPHeaderName
  public static let age: patrol.HTTPHeaderName
  public static let allow: patrol.HTTPHeaderName
  public static let authorization: patrol.HTTPHeaderName
  public static let cacheControl: patrol.HTTPHeaderName
  public static let connection: patrol.HTTPHeaderName
  public static let cookie: patrol.HTTPHeaderName
  public static let contentDisposition: patrol.HTTPHeaderName
  public static let contentEncoding: patrol.HTTPHeaderName
  public static let contentLanguage: patrol.HTTPHeaderName
  public static let contentLength: patrol.HTTPHeaderName
  public static let contentRange: patrol.HTTPHeaderName
  public static let contentType: patrol.HTTPHeaderName
  public static let date: patrol.HTTPHeaderName
  public static let eTag: patrol.HTTPHeaderName
  public static let expect: patrol.HTTPHeaderName
  public static let expires: patrol.HTTPHeaderName
  public static let forwarded: patrol.HTTPHeaderName
  public static let host: patrol.HTTPHeaderName
  public static let ifModifiedSince: patrol.HTTPHeaderName
  public static let lastModified: patrol.HTTPHeaderName
  public static let location: patrol.HTTPHeaderName
  public static let origin: patrol.HTTPHeaderName
  public static let pragma: patrol.HTTPHeaderName
  public static let range: patrol.HTTPHeaderName
  public static let referer: patrol.HTTPHeaderName
  public static let refresh: patrol.HTTPHeaderName
  public static let server: patrol.HTTPHeaderName
  public static let setCookie: patrol.HTTPHeaderName
  public static let strictTransportSecurity: patrol.HTTPHeaderName
  public static let transferEncoding: patrol.HTTPHeaderName
  public static let userAgent: patrol.HTTPHeaderName
  public static let upgrade: patrol.HTTPHeaderName
}
extension Swift.Dictionary where Key == patrol.HTTPHeaderName, Value == Swift.String {
  public var accept: Swift.String? {
    get
    set
  }
  public var acceptCharset: Swift.String? {
    get
    set
  }
  public var acceptEncoding: Swift.String? {
    get
    set
  }
  public var acceptLanguage: Swift.String? {
    get
    set
  }
  public var acceptRanges: Swift.String? {
    get
    set
  }
  public var accessControlAllowOrigin: Swift.String? {
    get
    set
  }
  public var accessControlAllowHeaders: Swift.String? {
    get
    set
  }
  public var accessControlAllowMethods: Swift.String? {
    get
    set
  }
  public var accessControlMaxAge: Swift.String? {
    get
    set
  }
  public var age: Swift.String? {
    get
    set
  }
  public var allow: Swift.String? {
    get
    set
  }
  public var authorization: Swift.String? {
    get
    set
  }
  public var cacheControl: Swift.String? {
    get
    set
  }
  public var connection: Swift.String? {
    get
    set
  }
  public var cookie: Swift.String? {
    get
    set
  }
  public var contentDisposition: Swift.String? {
    get
    set
  }
  public var contentEncoding: Swift.String? {
    get
    set
  }
  public var contentLanguage: Swift.String? {
    get
    set
  }
  public var contentLength: Swift.Int? {
    get
    set
  }
  public var contentRange: Swift.String? {
    get
    set
  }
  public var contentType: Swift.String? {
    get
    set
  }
  public var date: Swift.String? {
    get
    set
  }
  public var eTag: Swift.String? {
    get
    set
  }
  public var expect: Swift.String? {
    get
    set
  }
  public var expires: Swift.String? {
    get
    set
  }
  public var forwarded: Swift.String? {
    get
    set
  }
  public var host: Swift.String? {
    get
    set
  }
  public var ifModifiedSince: Swift.String? {
    get
    set
  }
  public var lastModified: Swift.String? {
    get
    set
  }
  public var location: Swift.String? {
    get
    set
  }
  public var origin: Swift.String? {
    get
    set
  }
  public var pragma: Swift.String? {
    get
    set
  }
  public var range: Swift.String? {
    get
    set
  }
  public var referer: Swift.String? {
    get
    set
  }
  public var refresh: Swift.String? {
    get
    set
  }
  public var server: Swift.String? {
    get
    set
  }
  public var setCookie: Swift.String? {
    get
    set
  }
  public var strictTransportSecurity: Swift.String? {
    get
    set
  }
  public var transferEncoding: Swift.String? {
    get
    set
  }
  public var userAgent: Swift.String? {
    get
    set
  }
  public var upgrade: Swift.String? {
    get
    set
  }
}
extension patrol.HTTPHeaderName {
  public static let webSocketAccept: patrol.HTTPHeaderName
  public static let webSocketKey: patrol.HTTPHeaderName
  public static let webSocketProtocol: patrol.HTTPHeaderName
  public static let webSocketVersion: patrol.HTTPHeaderName
}
extension Swift.Dictionary where Key == patrol.HTTPHeaderName, Value == Swift.String {
  public var webSocketAccept: Swift.String? {
    get
    set
  }
  public var webSocketKey: Swift.String? {
    get
    set
  }
  public var webSocketProtocol: Swift.String? {
    get
    set
  }
  public var webSocketVersion: Swift.String? {
    get
    set
  }
}
open class HTTPMessage {
  public var version: patrol.HTTPVersion
  public var headers: patrol.HTTPHeaders
  public var body: Foundation.Data
  public init(version: patrol.HTTPVersion = .default, headers: patrol.HTTPHeaders = .empty, body: Foundation.Data = Data())
  open func prepareForWrite()
  public func write(to stream: any patrol.WriteStream, headerTimeout: Foundation.TimeInterval, bodyTimeout: Foundation.TimeInterval)
  open func writeHeader(to stream: any patrol.WriteStream, timeout: Foundation.TimeInterval)
  open func writeBody(to stream: any patrol.WriteStream, timeout: Foundation.TimeInterval)
  @objc deinit
}
extension patrol.HTTPMessage {
  public var keepAlive: Swift.Bool {
    get
  }
  public var isConnectionUpgrade: Swift.Bool {
    get
  }
}
extension patrol.HTTPMessage {
  public static let webSocketMagicGUID: Swift.String
  public static let webSocketProtocol: Swift.String
  public static let webSocketVersion: Swift.String
  public var isWebSocketUpgrade: Swift.Bool {
    get
  }
}
extension patrol.HTTPRequest {
  public static func webSocketHandshake(host: Swift.String, port: Swift.Int = 80, protocolName: Swift.String? = nil) -> patrol.HTTPRequest
  public func webSocketHandshake(host: Swift.String, port: Swift.Int = 80, protocolName: Swift.String? = nil)
}
extension patrol.HTTPResponse {
  public static func webSocketHandshake(key: Swift.String, protocolName: Swift.String? = nil) -> patrol.HTTPResponse
  public func webSocketHandshake(key: Swift.String, protocolName: Swift.String? = nil)
  public var isWebSocketHandshake: Swift.Bool {
    get
  }
}
public struct HTTPMethod : Swift.Hashable {
  public let name: Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: patrol.HTTPMethod, b: patrol.HTTPMethod) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension patrol.HTTPMethod {
  public static let GET: patrol.HTTPMethod
  public static let HEAD: patrol.HTTPMethod
  public static let DELETE: patrol.HTTPMethod
  public static let POST: patrol.HTTPMethod
  public static let PUT: patrol.HTTPMethod
  public static let OPTIONS: patrol.HTTPMethod
  public static let CONNECT: patrol.HTTPMethod
  public static let TRACE: patrol.HTTPMethod
  public static let PATCH: patrol.HTTPMethod
}
extension patrol.HTTPMethod : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension patrol.HTTPMethod : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral string: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
final public class HTTPParser {
  final public var message: patrol.HTTPMessage? {
    get
  }
  final public var isMessageComplete: Swift.Bool {
    get
  }
  final public var isUpgradeDetected: Swift.Bool {
    get
  }
  public init()
  @discardableResult
  final public func parse(data: Foundation.Data) throws -> Swift.Int
  final public func reset()
  @objc deinit
}
open class HTTPRequest : patrol.HTTPMessage {
  public typealias Params = [Swift.String : Swift.String]
  public var method: patrol.HTTPMethod
  public var uri: patrol.URI
  public var params: patrol.HTTPRequest.Params
  public init(_ method: patrol.HTTPMethod = .GET, uri: patrol.URI = .root, version: patrol.HTTPVersion = .default, headers: patrol.HTTPHeaders = .empty, body: Foundation.Data = Data())
  override open func prepareForWrite()
  @objc deinit
}
extension patrol.HTTPRequest : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension patrol.HTTPRequest {
  public func setHostHeader(host: Swift.String?, port: Swift.Int? = nil)
}
public protocol HTTPRequestHandler {
  func respond(to request: patrol.HTTPRequest, nextHandler: (patrol.HTTPRequest) throws -> patrol.HTTPResponse?) throws -> patrol.HTTPResponse?
}
extension patrol.HTTPRequest {
  public typealias Handler = (patrol.HTTPRequest) throws -> patrol.HTTPResponse?
}
open class HTTPResponse : patrol.HTTPMessage {
  public typealias Handler = (patrol.HTTPResponse, any Swift.Error) -> Swift.Void
  public var status: patrol.HTTPStatus
  public init(_ status: patrol.HTTPStatus = .ok, version: patrol.HTTPVersion = .default, headers: patrol.HTTPHeaders = .empty, body: Foundation.Data = Data(), isComplete: Swift.Bool = true)
  override open func prepareForWrite()
  @objc deinit
}
extension patrol.HTTPResponse {
  convenience public init(_ status: patrol.HTTPStatus = .ok, headers: patrol.HTTPHeaders = .empty, content: Swift.String)
  convenience public init(_ status: patrol.HTTPStatus = .internalServerError, headers: patrol.HTTPHeaders = .empty, error: any Swift.Error)
}
extension patrol.HTTPResponse : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct HTTPRoute {
  public let methods: Swift.Set<patrol.HTTPMethod>?
  public let handler: patrol.HTTPRequest.Handler
  public let regex: patrol.Regex?
  public let params: [patrol.HTTPRequest.Params.Key]
  public init(methods: Swift.Set<patrol.HTTPMethod>? = nil, regex pattern: Swift.String? = nil, handler: @escaping patrol.HTTPRequest.Handler) throws
  public init(methods: Swift.Set<patrol.HTTPMethod>? = nil, uri: Swift.String, handler: @escaping patrol.HTTPRequest.Handler) throws
}
extension patrol.HTTPRoute {
  public func canHandle(method: patrol.HTTPMethod) -> Swift.Bool
  public func canHandle(path: Swift.String) -> (Swift.Bool, patrol.HTTPRequest.Params)
}
@_hasMissingDesignatedInitializers open class HTTPRouteHandler : patrol.HTTPRequestHandler {
  public var routes: [patrol.HTTPRoute]
  public var implicitHeadRequests: Swift.Bool
  open func respond(to request: patrol.HTTPRequest, nextHandler: (patrol.HTTPRequest) throws -> patrol.HTTPResponse?) throws -> patrol.HTTPResponse?
  @objc deinit
}
public struct HTTPStatus : Swift.Hashable {
  public let code: Swift.Int
  public let phrase: Swift.String
  public let strict: Swift.Bool
  public init(code: Swift.Int, phrase: Swift.String, strict: Swift.Bool = false)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension patrol.HTTPStatus {
  public var isInformational: Swift.Bool {
    get
  }
  public var isSuccess: Swift.Bool {
    get
  }
  public var isRedirection: Swift.Bool {
    get
  }
  public var isClientError: Swift.Bool {
    get
  }
  public var isServerError: Swift.Bool {
    get
  }
  public var supportsBody: Swift.Bool {
    get
  }
}
extension patrol.HTTPStatus {
  public static func == (lhs: patrol.HTTPStatus, rhs: patrol.HTTPStatus) -> Swift.Bool
}
extension patrol.HTTPStatus : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension patrol.HTTPStatus {
  public static let `continue`: patrol.HTTPStatus
  public static let switchingProtocols: patrol.HTTPStatus
  public static let processing: patrol.HTTPStatus
}
extension patrol.HTTPStatus {
  public static let ok: patrol.HTTPStatus
  public static let created: patrol.HTTPStatus
  public static let accepted: patrol.HTTPStatus
  public static let nonAuthoritativeInformation: patrol.HTTPStatus
  public static let noContent: patrol.HTTPStatus
  public static let resetContent: patrol.HTTPStatus
  public static let partialContent: patrol.HTTPStatus
  public static let multiStatus: patrol.HTTPStatus
  public static let alreadyReported: patrol.HTTPStatus
  public static let imUsed: patrol.HTTPStatus
}
extension patrol.HTTPStatus {
  public static let multipleChoices: patrol.HTTPStatus
  public static let movedPermanently: patrol.HTTPStatus
  public static let found: patrol.HTTPStatus
  public static let seeOther: patrol.HTTPStatus
  public static let notModified: patrol.HTTPStatus
  public static let useProxy: patrol.HTTPStatus
  public static let temporaryRedirect: patrol.HTTPStatus
  public static let permanentRedirect: patrol.HTTPStatus
}
extension patrol.HTTPStatus {
  public static let badRequest: patrol.HTTPStatus
  public static let unauthorized: patrol.HTTPStatus
  public static let paymentRequired: patrol.HTTPStatus
  public static let forbidden: patrol.HTTPStatus
  public static let notFound: patrol.HTTPStatus
  public static let methodNotAllowed: patrol.HTTPStatus
  public static let notAcceptable: patrol.HTTPStatus
  public static let proxyAuthenticationRequired: patrol.HTTPStatus
  public static let requestTimeout: patrol.HTTPStatus
  public static let conflict: patrol.HTTPStatus
  public static let gone: patrol.HTTPStatus
  public static let lengthRequired: patrol.HTTPStatus
  public static let preconditionFailed: patrol.HTTPStatus
  public static let payloadTooLarge: patrol.HTTPStatus
  public static let uriTooLong: patrol.HTTPStatus
  public static let unsupportedMediaType: patrol.HTTPStatus
  public static let rangeNotSatisfiable: patrol.HTTPStatus
  public static let expectationFailed: patrol.HTTPStatus
  public static let misdirectedRequest: patrol.HTTPStatus
  public static let unprocessableEntity: patrol.HTTPStatus
  public static let locked: patrol.HTTPStatus
  public static let failedDependency: patrol.HTTPStatus
  public static let upgradeRequired: patrol.HTTPStatus
  public static let preconditionRequired: patrol.HTTPStatus
  public static let tooManyRequests: patrol.HTTPStatus
  public static let requestHeaderFieldsTooLarge: patrol.HTTPStatus
  public static let unavailableForLegalReasons: patrol.HTTPStatus
}
extension patrol.HTTPStatus {
  public static let internalServerError: patrol.HTTPStatus
  public static let notImplemented: patrol.HTTPStatus
  public static let badGateway: patrol.HTTPStatus
  public static let serviceUnavailable: patrol.HTTPStatus
  public static let gatewayTimeout: patrol.HTTPStatus
  public static let httpVersionNotSupported: patrol.HTTPStatus
  public static let variantAlsoNegotiates: patrol.HTTPStatus
  public static let insufficientStorage: patrol.HTTPStatus
  public static let loopDetected: patrol.HTTPStatus
  public static let notExtended: patrol.HTTPStatus
  public static let networkAuthenticationRequired: patrol.HTTPStatus
}
public struct HTTPVersion {
  public let major: Swift.UInt
  public let minor: Swift.UInt
  public init(major: Swift.UInt, minor: Swift.UInt)
}
extension patrol.HTTPVersion {
  public static let `default`: patrol.HTTPVersion
}
extension patrol.HTTPVersion : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
open class HTTPWebSocketHandler : patrol.HTTPRequestHandler {
  public init(protocolName: Swift.String? = nil)
  open func respond(to request: patrol.HTTPRequest, nextHandler: (patrol.HTTPRequest) throws -> patrol.HTTPResponse?) throws -> patrol.HTTPResponse?
  @objc deinit
}
public enum KeychainError : Swift.Error {
  case invalidResult
  case itemAlreadyExists
  case itemNotFound
  case other(code: Darwin.OSStatus)
}
extension patrol.KeychainError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension patrol.KeychainError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class KeychainManager {
  public static let shared: patrol.KeychainManager
  public var accessibility: CoreFoundation.CFString
  public typealias KeychainClass = CoreFoundation.CFString
  public typealias KeychainValue = Swift.AnyObject
  public typealias KeychainQuery = [Foundation.NSString : Swift.AnyObject]
  @objc deinit
}
extension patrol.KeychainManager {
  public func importPKCS12(data: Foundation.Data, passphrase: Swift.String, options: patrol.KeychainManager.KeychainQuery = KeychainQuery()) -> Security.SecIdentity?
}
extension patrol.KeychainManager {
  public func add(value: patrol.KeychainManager.KeychainValue, label: Swift.String, options: patrol.KeychainManager.KeychainQuery = KeychainQuery()) throws
  public func find<T>(_ kClass: patrol.KeychainManager.KeychainClass, label: Swift.String, options: patrol.KeychainManager.KeychainQuery = KeychainQuery()) throws -> T
  public func remove(_ kClass: patrol.KeychainManager.KeychainClass, label: Swift.String, options: patrol.KeychainManager.KeychainQuery = KeychainQuery()) throws
}
public typealias Regex = Foundation.NSRegularExpression
@objc public class ObjCRunDartTestResponse : ObjectiveC.NSObject {
  @objc dynamic final public let passed: Swift.Bool
  @objc dynamic final public let details: Swift.String?
  @objc public init(passed: Swift.Bool, details: Swift.String?)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class ObjCPatrolAppServiceClient : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public func listDartTests(completion: @escaping ([[Swift.String : Any]]?, (any Swift.Error)?) -> Swift.Void)
  @objc public func runDartTest(name: Swift.String, completion: @escaping (patrol.ObjCRunDartTestResponse?, (any Swift.Error)?) -> Swift.Void)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class PatrolServer : ObjectiveC.NSObject {
  @objc public var appReady: Swift.Bool {
    get
  }
  @objc override dynamic public init()
  @objc public func start() throws
  @objc deinit
}
public struct RFC1123 {
  public static var formatter: Foundation.DateFormatter
}
extension Foundation.DateFormatter {
  public static var rfc1123: Foundation.DateFormatter {
    get
  }
}
extension Foundation.Date {
  public var rfc1123: Swift.String {
    get
  }
}
open class Server {
  weak public var delegate: (any patrol.ServerDelegate)?
  public var delegateQueue: Dispatch.DispatchQueue
  public var httpConfig: patrol.HTTPConfig
  public var webSocketConfig: patrol.WebSocketConfig
  weak public var webSocketDelegate: (any patrol.ServerWebSocketDelegate)?
  public init()
  public init(identity: patrol.CertificateIdentity, caCertificates: [patrol.Certificate])
  open func start(port: patrol.Endpoint.Port = 0, interface: Swift.String? = nil) throws
  open func stop(immediately: Swift.Bool = false)
  open func handleIncoming(socket: patrol.TCPSocket)
  open func handleIncoming(request: patrol.HTTPRequest, connection: patrol.HTTPConnection, error: (any Swift.Error)?)
  open func handleUpgrade(request: patrol.HTTPRequest, connection: patrol.HTTPConnection)
  open func responseFor(request: patrol.HTTPRequest) throws -> patrol.HTTPResponse?
  open func responseFor(error: any Swift.Error) -> patrol.HTTPResponse?
  @objc deinit
}
extension patrol.Server {
  public var concurrency: Swift.Int {
    get
    set
  }
  public var port: patrol.Endpoint.Port {
    get
  }
  public var isRunning: Swift.Bool {
    get
  }
  public var isSecure: Swift.Bool {
    get
  }
  public var httpConnections: Swift.Set<patrol.HTTPConnection> {
    get
  }
  public var httpConnectionCount: Swift.Int {
    get
  }
  public var webSocketConnections: Swift.Set<patrol.WebSocketConnection> {
    get
  }
  public var webSockets: [any patrol.WebSocket] {
    get
  }
  public var webSocketCount: Swift.Int {
    get
  }
}
extension patrol.Server : patrol.TCPListenerDelegate {
  public func listener(_ listener: patrol.TCPListener, didAcceptSocket socket: patrol.TCPSocket)
  public func listenerDisconnected(_ listener: patrol.TCPListener, error: (any Swift.Error)?)
}
extension patrol.Server : patrol.HTTPConnectionDelegate {
  public func connection(_ httpConnection: patrol.HTTPConnection, handleIncomingRequest request: patrol.HTTPRequest, error: (any Swift.Error)?)
  public func connection(_ httpConnection: patrol.HTTPConnection, handleIncomingResponse response: patrol.HTTPResponse, error: (any Swift.Error)?)
  public func connection(_ httpConnection: patrol.HTTPConnection, handleUpgradeByRequest request: patrol.HTTPRequest)
  public func connection(_ httpConnection: patrol.HTTPConnection, didCloseWithError error: (any Swift.Error)?)
}
extension patrol.Server : patrol.WebSocketConnectionDelegate {
  public func connection(_ webSocketConnection: patrol.WebSocketConnection, didReceiveMessage message: patrol.WebSocketMessage)
  public func connection(_ webSocketConnection: patrol.WebSocketConnection, didSendMessage message: patrol.WebSocketMessage)
  public func connection(_ webSocketConnection: patrol.WebSocketConnection, didCloseWithError error: (any Swift.Error)?)
}
extension patrol.HTTPConfig {
  public static var serverDefault: patrol.HTTPConfig {
    get
  }
}
extension patrol.WebSocketConfig {
  public static var serverDefault: patrol.WebSocketConfig {
    get
  }
}
extension patrol.Server {
  public func route(_ method: patrol.HTTPMethod, _ uri: Swift.String, _ handler: @escaping patrol.HTTPRequest.Handler)
  public func route(_ method: patrol.HTTPMethod, regex: Swift.String, _ handler: @escaping patrol.HTTPRequest.Handler)
  public func route(_ httpRoute: patrol.HTTPRoute)
}
extension patrol.Server {
  public func route(_ method: patrol.HTTPMethod, _ uri: Swift.String, response: @escaping () -> patrol.HTTPResponse)
  public func route(_ method: patrol.HTTPMethod, _ uri: Swift.String, status: @escaping () -> patrol.HTTPStatus)
  public func route(_ method: patrol.HTTPMethod, _ uri: Swift.String, content: @escaping () -> (patrol.HTTPStatus, Swift.String))
}
public protocol ServerDelegate : AnyObject {
  func serverDidStop(_ server: patrol.Server, error: (any Swift.Error)?)
}
public protocol ServerWebSocketDelegate : AnyObject {
  func server(_ server: patrol.Server, webSocketDidConnect webSocket: any patrol.WebSocket, handshake: patrol.HTTPRequest)
  func server(_ server: patrol.Server, webSocketDidDisconnect webSocket: any patrol.WebSocket, error: (any Swift.Error)?)
  func server(_ server: patrol.Server, webSocket: any patrol.WebSocket, didReceiveMessage message: patrol.WebSocketMessage)
  func server(_ server: patrol.Server, webSocket: any patrol.WebSocket, didSendMessage message: patrol.WebSocketMessage)
  func serverDidDisconnect(_ server: patrol.Server)
}
extension patrol.ServerWebSocketDelegate {
  public func server(_ server: patrol.Server, webSocket: any patrol.WebSocket, didSendMessage message: patrol.WebSocketMessage)
  public func serverDidDisconnect(_ server: patrol.Server)
}
public struct SHA1 {
  public let digest: Foundation.Data
  public init(data: Foundation.Data)
}
extension patrol.SHA1 {
  public static func hash(_ data: Foundation.Data) -> Foundation.Data
  public static func hash(_ string: Swift.String) -> Foundation.Data
}
public protocol ReadStream {
  func read(timeout: Foundation.TimeInterval)
}
public protocol WriteStream {
  func flush()
  func write(data: Foundation.Data, timeout: Foundation.TimeInterval)
}
extension Swift.String {
  public var base64: Swift.String {
    get
  }
  public var utf8Data: Foundation.Data {
    get
  }
  public func truncate(count: Swift.Int, ellipses: Swift.Bool = true) -> Swift.String
}
@objc @_inheritsConvenienceInitializers public class SwiftPatrolPlugin : ObjectiveC.NSObject, Flutter.FlutterPlugin {
  @objc public static func register(with registrar: any Flutter.FlutterPluginRegistrar)
  @objc public func handle(_ call: Flutter.FlutterMethodCall, result: @escaping Flutter.FlutterResult)
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SynchronizedSet<Element> where Element : Swift.Hashable {
  @objc deinit
}
extension patrol.SynchronizedSet {
  public var count: Swift.Int {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension patrol.SynchronizedSet {
  public func insert(_ element: Element)
  public func remove(_ element: Element)
}
extension patrol.SynchronizedSet {
  public func contains(_ element: Element) -> Swift.Bool
  public func forEach(_ body: (Element) -> Swift.Void)
}
extension patrol.SynchronizedSet {
  public func toArray() -> [Element]
  public func toSet() -> Swift.Set<Element>
}
public protocol TCPConnection : AnyObject, Swift.Hashable {
  var localEndpoint: patrol.Endpoint? { get }
  var remoteEndpoint: patrol.Endpoint? { get }
  func open()
  func close(immediately: Swift.Bool)
}
extension patrol.TCPConnection {
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol TCPListenerDelegate : AnyObject {
  func listener(_ listener: patrol.TCPListener, didAcceptSocket socket: patrol.TCPSocket)
  func listenerDisconnected(_ listener: patrol.TCPListener, error: (any Swift.Error)?)
}
@objc final public class TCPListener : ObjectiveC.NSObject {
  weak final public var delegate: (any patrol.TCPListenerDelegate)?
  final public let interface: Swift.String?
  final public let tlsConfig: patrol.TLSConfig?
  public init(port: patrol.Endpoint.Port, interface: Swift.String? = nil, tlsConfig: patrol.TLSConfig? = nil)
  final public var isListening: Swift.Bool {
    get
  }
  final public var port: patrol.Endpoint.Port {
    get
  }
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  final public func start(queue: Dispatch.DispatchQueue) throws
  final public func stop()
  @objc deinit
}
extension patrol.TCPListener : CocoaAsyncSocket.GCDAsyncSocketDelegate {
  @objc final public func socket(_ sock: CocoaAsyncSocket.GCDAsyncSocket, didAcceptNewSocket newSocket: CocoaAsyncSocket.GCDAsyncSocket)
  @objc final public func socketDidDisconnect(_ sock: CocoaAsyncSocket.GCDAsyncSocket, withError err: (any Swift.Error)?)
}
public enum TCPSocketClose {
  case immediately
  case afterReading
  case afterWriting
  case afterReadingAndWriting
  public static func == (a: patrol.TCPSocketClose, b: patrol.TCPSocketClose) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol TCPSocketDelegate : AnyObject {
  func socketDidOpen(_ socket: patrol.TCPSocket)
  func socketDidClose(_ socket: patrol.TCPSocket, error: (any Swift.Error)?)
  func socketDidRead(_ socket: patrol.TCPSocket, data: Foundation.Data, tag: Swift.Int)
  func socketDidWrite(_ socket: patrol.TCPSocket, tag: Swift.Int)
}
@objc @_hasMissingDesignatedInitializers final public class TCPSocket : ObjectiveC.NSObject {
  final public let endpoint: patrol.Endpoint
  weak final public var delegate: (any patrol.TCPSocketDelegate)?
  public init(endpoint: patrol.Endpoint, tlsPolicy: patrol.TLSPolicy? = nil)
  final public var isConnected: Swift.Bool {
    get
  }
  final public var localEndpoint: patrol.Endpoint? {
    get
  }
  final public var remoteEndpoint: patrol.Endpoint? {
    get
  }
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  final public func setDelegate(_ delegate: any patrol.TCPSocketDelegate, queue: Dispatch.DispatchQueue)
  final public func setDelegateQueue(_ queue: Dispatch.DispatchQueue)
  final public func connect(timeout: Foundation.TimeInterval = 30)
  final public func close(when: patrol.TCPSocketClose = .immediately)
  final public func read(timeout: Foundation.TimeInterval = -1, tag: Swift.Int = 0)
  final public func read(maxLength: Swift.Int, timeout: Foundation.TimeInterval = -1, tag: Swift.Int = 0)
  final public func write(data: Foundation.Data, timeout: Foundation.TimeInterval = -1, tag: Swift.Int = 0)
  final public func startTLS(config: patrol.TLSConfig = TLSConfig())
  @objc deinit
}
extension patrol.TCPSocket : patrol.ReadStream, patrol.WriteStream {
  final public func read(timeout: Foundation.TimeInterval)
  final public func write(data: Foundation.Data, timeout: Foundation.TimeInterval)
  final public func flush()
}
extension patrol.TCPSocket : CocoaAsyncSocket.GCDAsyncSocketDelegate {
  @objc final public func socket(_ sock: CocoaAsyncSocket.GCDAsyncSocket, didConnectToHost host: Swift.String, port: Swift.UInt16)
  @objc final public func socketDidDisconnect(_ sock: CocoaAsyncSocket.GCDAsyncSocket, withError err: (any Swift.Error)?)
  @objc final public func socket(_ sock: CocoaAsyncSocket.GCDAsyncSocket, didRead data: Foundation.Data, withTag tag: Swift.Int)
  @objc final public func socket(_ sock: CocoaAsyncSocket.GCDAsyncSocket, didWriteDataWithTag tag: Swift.Int)
  @objc final public func socket(_ sock: CocoaAsyncSocket.GCDAsyncSocket, didReceive trust: Security.SecTrust, completionHandler: @escaping (Swift.Bool) -> Swift.Void)
}
public struct TLSConfig {
  public let identity: patrol.CertificateIdentity?
  public let certificates: [patrol.Certificate]
  public init(serverIdentity: patrol.CertificateIdentity, caCertificates: [patrol.Certificate])
  public init(clientCertificates: [patrol.Certificate] = [])
}
open class TLSPolicy {
  public var commonName: Swift.String?
  public var certificates: [patrol.Certificate]
  public init(commonName: Swift.String? = nil, certificates: [patrol.Certificate] = [])
  public func evaluate(trust: Security.SecTrust) -> Swift.Bool
  @objc deinit
}
extension patrol.TLSPolicy {
  public func evaluateSession(trust: Security.SecTrust?) -> Foundation.URLCredential?
}
extension Swift.UInt8 {
  public static var random: Swift.UInt8 {
    get
  }
}
extension Swift.UInt16 {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.UInt32 {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.UInt64 {
  public var bytes: [Swift.UInt8] {
    get
  }
}
public struct URI : Swift.Hashable, Swift.Equatable {
  public init(path: Swift.String = "/", query: Swift.String? = nil)
  public init(components: Foundation.URLComponents)
  public init?(url: Foundation.URL)
  public init?(_ string: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: patrol.URI, b: patrol.URI) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension patrol.URI {
  public var path: Swift.String {
    get
    set
  }
  public var query: Swift.String? {
    get
    set
  }
  public var queryItems: [Foundation.URLQueryItem]? {
    get
    set
  }
}
extension patrol.URI {
  public init(percentEncodedPath: Swift.String, percentEncodedQuery: Swift.String? = nil)
  public var percentEncodedPath: Swift.String {
    get
    set
  }
  public var percentEncodedQuery: Swift.String? {
    get
    set
  }
  public var string: Swift.String {
    get
  }
}
extension patrol.URI {
  public static let root: patrol.URI
  public func relativePath(from path: Swift.String) -> Swift.String?
}
extension patrol.URI : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Foundation.URL {
  public var hasWebSocketScheme: Swift.Bool {
    get
  }
  public var portBasedOnScheme: Swift.Int {
    get
  }
  public var isSchemeSecure: Swift.Bool {
    get
  }
}
extension Foundation.URL {
  public var mimeType: Swift.String {
    get
  }
}
public protocol WebSocket : AnyObject {
  var localEndpoint: patrol.Endpoint? { get }
  var remoteEndpoint: patrol.Endpoint? { get }
  func close(immediately: Swift.Bool)
  func send(data: Foundation.Data)
  func send(text: Swift.String)
  func send(message: patrol.WebSocketMessage)
}
extension patrol.WebSocket {
  public func send(data: Foundation.Data)
  public func send(text: Swift.String)
}
public protocol WebSocketClientDelegate : AnyObject {
  func webSocketClient(_ client: patrol.WebSocketClient, didConnectToHost host: Swift.String)
  func webSocketClient(_ client: patrol.WebSocketClient, didDisconnectWithError error: (any Swift.Error)?)
  func webSocketClient(_ client: patrol.WebSocketClient, didReceiveData data: Foundation.Data)
  func webSocketClient(_ client: patrol.WebSocketClient, didReceiveText text: Swift.String)
}
open class WebSocketClient : patrol.WebSocket {
  final public let url: Foundation.URL
  public var headers: patrol.HTTPHeaders
  public var config: patrol.WebSocketConfig
  public var tlsPolicy: patrol.TLSPolicy?
  weak public var delegate: (any patrol.WebSocketClientDelegate)?
  public init(url: Foundation.URL, headers: patrol.HTTPHeaders = .empty) throws
  public func connect(timeout: Foundation.TimeInterval = 10)
  public func disconnect()
  public func close(immediately: Swift.Bool)
  public func send(message: patrol.WebSocketMessage)
  @objc deinit
}
extension patrol.WebSocketClient {
  public var localEndpoint: patrol.Endpoint? {
    get
  }
  public var remoteEndpoint: patrol.Endpoint? {
    get
  }
}
extension patrol.WebSocketClient {
  convenience public init(_ string: Swift.String) throws
  convenience public init(_ string: Swift.String, certificates: [patrol.Certificate]) throws
  convenience public init(url: Foundation.URL, certificates: [patrol.Certificate]) throws
}
extension patrol.WebSocketClient : patrol.TCPSocketDelegate {
  public func socketDidOpen(_ socket: patrol.TCPSocket)
  public func socketDidClose(_ socket: patrol.TCPSocket, error: (any Swift.Error)?)
  public func socketDidRead(_ socket: patrol.TCPSocket, data: Foundation.Data, tag: Swift.Int)
  public func socketDidWrite(_ socket: patrol.TCPSocket, tag: Swift.Int)
}
extension patrol.WebSocketClient : patrol.HTTPConnectionDelegate {
  public func connection(_ httpConnection: patrol.HTTPConnection, didCloseWithError error: (any Swift.Error)?)
  public func connection(_ httpConnection: patrol.HTTPConnection, handleIncomingResponse response: patrol.HTTPResponse, error: (any Swift.Error)?)
  public func connection(_ httpConnection: patrol.HTTPConnection, handleIncomingRequest request: patrol.HTTPRequest, error: (any Swift.Error)?)
  public func connection(_ httpConnection: patrol.HTTPConnection, handleUpgradeByRequest request: patrol.HTTPRequest)
}
extension patrol.WebSocketClient : patrol.WebSocketConnectionDelegate {
  public func connection(_ webSocketConnection: patrol.WebSocketConnection, didCloseWithError error: (any Swift.Error)?)
  public func connection(_ webSocketConnection: patrol.WebSocketConnection, didReceiveMessage message: patrol.WebSocketMessage)
  public func connection(_ webSocketConnection: patrol.WebSocketConnection, didSendMessage message: patrol.WebSocketMessage)
}
public struct WebSocketConfig {
  public var readTimeout: Swift.Double
  public var writeHeaderTimeout: Swift.Double
  public var writePayloadTimeout: Swift.Double
  public var maskMessages: Swift.Bool
  public var pingInterval: Swift.Double
  public var errorHandler: any patrol.WebSocketErrorHandler
  public var messageHandler: any patrol.WebSocketMessageHandler
  public init()
}
public protocol WebSocketConnectionDelegate : AnyObject {
  func connection(_ webSocketConnection: patrol.WebSocketConnection, didReceiveMessage message: patrol.WebSocketMessage)
  func connection(_ webSocketConnection: patrol.WebSocketConnection, didSendMessage message: patrol.WebSocketMessage)
  func connection(_ webSocketConnection: patrol.WebSocketConnection, didCloseWithError error: (any Swift.Error)?)
}
open class WebSocketConnection : patrol.TCPConnection, patrol.WebSocket {
  weak public var delegate: (any patrol.WebSocketConnectionDelegate)?
  required public init(socket: patrol.TCPSocket, config: patrol.WebSocketConfig)
  public func open()
  public func open(data: Foundation.Data?)
  public func close(immediately: Swift.Bool)
  public func send(message: patrol.WebSocketMessage)
  @objc deinit
  open var hashValue: Swift.Int {
    get
  }
}
extension patrol.WebSocketConnection {
  public var localEndpoint: patrol.Endpoint? {
    get
  }
  public var remoteEndpoint: patrol.Endpoint? {
    get
  }
}
extension patrol.WebSocketConnection : patrol.TCPSocketDelegate {
  public func socketDidOpen(_ socket: patrol.TCPSocket)
  public func socketDidClose(_ socket: patrol.TCPSocket, error: (any Swift.Error)?)
  public func socketDidRead(_ socket: patrol.TCPSocket, data: Foundation.Data, tag: Swift.Int)
  public func socketDidWrite(_ socket: patrol.TCPSocket, tag: Swift.Int)
}
extension patrol.WebSocketConnection : patrol.WebSocketParserDelegate {
  public func parser(_ parser: patrol.WebSocketParser, didCompleteMessage message: patrol.WebSocketMessage)
}
public enum WebSocketError : Swift.Error {
  case invalidMessage
  case invalidOpcode
  case invalidPayloadLength
  case payloadIsNotText
  case payloadTooLarge
  public static func == (a: patrol.WebSocketError, b: patrol.WebSocketError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension patrol.WebSocketError {
  public var code: Swift.UInt16 {
    get
  }
}
extension patrol.WebSocketError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension patrol.WebSocketError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class WebSocketErrorDefaultHandler : patrol.WebSocketErrorHandler {
  public func incoming(error: any Swift.Error, webSocket: any patrol.WebSocket, message: patrol.WebSocketMessage?)
  public func outgoing(error: any Swift.Error, webSocket: any patrol.WebSocket, message: patrol.WebSocketMessage?)
  @objc deinit
}
public protocol WebSocketErrorHandler {
  func incoming(error: any Swift.Error, webSocket: any patrol.WebSocket, message: patrol.WebSocketMessage?)
  func outgoing(error: any Swift.Error, webSocket: any patrol.WebSocket, message: patrol.WebSocketMessage?)
}
open class WebSocketMessage {
  public var finBit: Swift.Bool
  public var maskBit: Swift.Bool
  public var opcode: patrol.WebSocketOpcode
  public var payload: patrol.WebSocketPayload
  public init(opcode: patrol.WebSocketOpcode = .connectionClose, payload: patrol.WebSocketPayload = .none)
  @objc deinit
}
public enum WebSocketOpcode : Swift.UInt8 {
  case continuationFrame
  case textFrame
  case binaryFrame
  case connectionClose
  case ping
  case pong
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum WebSocketPayload {
  case none
  case binary(Foundation.Data)
  case text(Swift.String)
  case close(code: Swift.UInt16, reason: Swift.String)
}
public struct WebSocketMasks {
}
extension patrol.WebSocketMessage {
  convenience public init(closeCode: Swift.UInt16, reason: Swift.String = "")
  convenience public init(error: patrol.WebSocketError)
  convenience public init(data: Foundation.Data)
  convenience public init(text: Swift.String)
}
extension patrol.WebSocketMessage {
  public func generateMask() -> [Swift.UInt8]
}
extension patrol.WebSocketMessage : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension patrol.WebSocketMessage {
  public func write(to stream: any patrol.WriteStream, headerTimeout: Foundation.TimeInterval, payloadTimeout: Foundation.TimeInterval)
}
extension patrol.WebSocketPayload {
  public var data: Foundation.Data? {
    get
  }
}
@_hasMissingDesignatedInitializers public class WebSocketMessageDefaultHandler : patrol.WebSocketMessageHandler {
  public func incoming(message: patrol.WebSocketMessage, from webSocket: any patrol.WebSocket) throws
  public func outgoing(message: patrol.WebSocketMessage, to webSocket: any patrol.WebSocket) throws
  @objc deinit
}
public protocol WebSocketMessageHandler {
  func incoming(message: patrol.WebSocketMessage, from webSocket: any patrol.WebSocket) throws
  func outgoing(message: patrol.WebSocketMessage, to webSocket: any patrol.WebSocket) throws
}
public protocol WebSocketParserDelegate : AnyObject {
  func parser(_ parser: patrol.WebSocketParser, didCompleteMessage message: patrol.WebSocketMessage)
}
public class WebSocketParser {
  final public let maxPayloadLength: Swift.UInt64
  weak public var delegate: (any patrol.WebSocketParserDelegate)?
  public var message: patrol.WebSocketMessage {
    get
  }
  public var maskingKey: [Swift.UInt8] {
    get
  }
  public var payload: Foundation.Data {
    get
  }
  public var nextPart: patrol.WebSocketParser.Part {
    get
  }
  public var bytesParsed: Swift.Int {
    get
  }
  public var payloadLength: Swift.UInt64 {
    get
  }
  public enum Part {
    case finAndOpcode
    case maskAndPayloadLength
    case extendedPayloadLength16(byteNo: Swift.Int)
    case extendedPayloadLength64(byteNo: Swift.Int)
    case maskingKey(byteNo: Swift.Int)
    case payload
    case endOfMessage
  }
  public init(maxPayloadLength: Swift.Int = 10_485_760)
  public func parse(data: Foundation.Data) throws
  public func reset()
  @objc deinit
}
extension patrol.GroupEntryType : Swift.Equatable {}
extension patrol.GroupEntryType : Swift.Hashable {}
extension patrol.GroupEntryType : Swift.RawRepresentable {}
extension patrol.RunDartTestResponseResult : Swift.Equatable {}
extension patrol.RunDartTestResponseResult : Swift.Hashable {}
extension patrol.RunDartTestResponseResult : Swift.RawRepresentable {}
extension patrol.KeyboardBehavior : Swift.Equatable {}
extension patrol.KeyboardBehavior : Swift.Hashable {}
extension patrol.KeyboardBehavior : Swift.RawRepresentable {}
extension patrol.HandlePermissionRequestCode : Swift.Equatable {}
extension patrol.HandlePermissionRequestCode : Swift.Hashable {}
extension patrol.HandlePermissionRequestCode : Swift.RawRepresentable {}
extension patrol.SetLocationAccuracyRequestLocationAccuracy : Swift.Equatable {}
extension patrol.SetLocationAccuracyRequestLocationAccuracy : Swift.Hashable {}
extension patrol.SetLocationAccuracyRequestLocationAccuracy : Swift.RawRepresentable {}
extension patrol.IOSElementType : Swift.Equatable {}
extension patrol.IOSElementType : Swift.Hashable {}
extension patrol.IOSElementType : Swift.RawRepresentable {}
@available(*, deprecated, message: "these specific errors are no longer thrown")
extension patrol.HTTPRouteError : Swift.Equatable {}
@available(*, deprecated, message: "these specific errors are no longer thrown")
extension patrol.HTTPRouteError : Swift.Hashable {}
extension patrol.TCPSocketClose : Swift.Equatable {}
extension patrol.TCPSocketClose : Swift.Hashable {}
extension patrol.WebSocketError : Swift.Equatable {}
extension patrol.WebSocketError : Swift.Hashable {}
extension patrol.WebSocketOpcode : Swift.Equatable {}
extension patrol.WebSocketOpcode : Swift.Hashable {}
extension patrol.WebSocketOpcode : Swift.RawRepresentable {}
